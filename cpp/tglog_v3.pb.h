// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tglog_v3.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tglog_5fv3_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tglog_5fv3_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tglog_5fv3_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tglog_5fv3_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tglog_5fv3_2eproto;
namespace tglog_v3 {
class AuthReq;
struct AuthReqDefaultTypeInternal;
extern AuthReqDefaultTypeInternal _AuthReq_default_instance_;
class AuthReq_AnnotationsEntry_DoNotUse;
struct AuthReq_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern AuthReq_AnnotationsEntry_DoNotUseDefaultTypeInternal _AuthReq_AnnotationsEntry_DoNotUse_default_instance_;
class AuthReq_LabelsEntry_DoNotUse;
struct AuthReq_LabelsEntry_DoNotUseDefaultTypeInternal;
extern AuthReq_LabelsEntry_DoNotUseDefaultTypeInternal _AuthReq_LabelsEntry_DoNotUse_default_instance_;
class AuthRsp;
struct AuthRspDefaultTypeInternal;
extern AuthRspDefaultTypeInternal _AuthRsp_default_instance_;
class HeartbeatReq;
struct HeartbeatReqDefaultTypeInternal;
extern HeartbeatReqDefaultTypeInternal _HeartbeatReq_default_instance_;
class HeartbeatRsp;
struct HeartbeatRspDefaultTypeInternal;
extern HeartbeatRspDefaultTypeInternal _HeartbeatRsp_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class LogReq;
struct LogReqDefaultTypeInternal;
extern LogReqDefaultTypeInternal _LogReq_default_instance_;
class LogReq_AnnotationsEntry_DoNotUse;
struct LogReq_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern LogReq_AnnotationsEntry_DoNotUseDefaultTypeInternal _LogReq_AnnotationsEntry_DoNotUse_default_instance_;
class LogReq_LabelsEntry_DoNotUse;
struct LogReq_LabelsEntry_DoNotUseDefaultTypeInternal;
extern LogReq_LabelsEntry_DoNotUseDefaultTypeInternal _LogReq_LabelsEntry_DoNotUse_default_instance_;
class LogRsp;
struct LogRspDefaultTypeInternal;
extern LogRspDefaultTypeInternal _LogRsp_default_instance_;
class Req;
struct ReqDefaultTypeInternal;
extern ReqDefaultTypeInternal _Req_default_instance_;
class ReqHeader;
struct ReqHeaderDefaultTypeInternal;
extern ReqHeaderDefaultTypeInternal _ReqHeader_default_instance_;
class Rsp;
struct RspDefaultTypeInternal;
extern RspDefaultTypeInternal _Rsp_default_instance_;
class RspHeader;
struct RspHeaderDefaultTypeInternal;
extern RspHeaderDefaultTypeInternal _RspHeader_default_instance_;
}  // namespace tglog_v3
PROTOBUF_NAMESPACE_OPEN
template<> ::tglog_v3::AuthReq* Arena::CreateMaybeMessage<::tglog_v3::AuthReq>(Arena*);
template<> ::tglog_v3::AuthReq_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::tglog_v3::AuthReq_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::tglog_v3::AuthReq_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::tglog_v3::AuthReq_LabelsEntry_DoNotUse>(Arena*);
template<> ::tglog_v3::AuthRsp* Arena::CreateMaybeMessage<::tglog_v3::AuthRsp>(Arena*);
template<> ::tglog_v3::HeartbeatReq* Arena::CreateMaybeMessage<::tglog_v3::HeartbeatReq>(Arena*);
template<> ::tglog_v3::HeartbeatRsp* Arena::CreateMaybeMessage<::tglog_v3::HeartbeatRsp>(Arena*);
template<> ::tglog_v3::Log* Arena::CreateMaybeMessage<::tglog_v3::Log>(Arena*);
template<> ::tglog_v3::LogReq* Arena::CreateMaybeMessage<::tglog_v3::LogReq>(Arena*);
template<> ::tglog_v3::LogReq_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::tglog_v3::LogReq_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::tglog_v3::LogReq_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::tglog_v3::LogReq_LabelsEntry_DoNotUse>(Arena*);
template<> ::tglog_v3::LogRsp* Arena::CreateMaybeMessage<::tglog_v3::LogRsp>(Arena*);
template<> ::tglog_v3::Req* Arena::CreateMaybeMessage<::tglog_v3::Req>(Arena*);
template<> ::tglog_v3::ReqHeader* Arena::CreateMaybeMessage<::tglog_v3::ReqHeader>(Arena*);
template<> ::tglog_v3::Rsp* Arena::CreateMaybeMessage<::tglog_v3::Rsp>(Arena*);
template<> ::tglog_v3::RspHeader* Arena::CreateMaybeMessage<::tglog_v3::RspHeader>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tglog_v3 {

enum ProtoVer : int {
  VER_USELESS = 0,
  MAJOR = 0,
  MINOR = 2,
  PATCH = 0,
  ProtoVer_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtoVer_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtoVer_IsValid(int value);
constexpr ProtoVer ProtoVer_MIN = VER_USELESS;
constexpr ProtoVer ProtoVer_MAX = MINOR;
constexpr int ProtoVer_ARRAYSIZE = ProtoVer_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtoVer_descriptor();
template<typename T>
inline const std::string& ProtoVer_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtoVer>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtoVer_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtoVer_descriptor(), enum_t_value);
}
inline bool ProtoVer_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtoVer* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtoVer>(
    ProtoVer_descriptor(), name, value);
}
enum Magic : int {
  MAGIC_USELESS = 0,
  VAL = 1537,
  Magic_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Magic_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Magic_IsValid(int value);
constexpr Magic Magic_MIN = MAGIC_USELESS;
constexpr Magic Magic_MAX = VAL;
constexpr int Magic_ARRAYSIZE = Magic_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Magic_descriptor();
template<typename T>
inline const std::string& Magic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Magic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Magic_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Magic_descriptor(), enum_t_value);
}
inline bool Magic_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Magic* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Magic>(
    Magic_descriptor(), name, value);
}
enum Len : int {
  LEN_USELESS = 0,
  MAGIC = 2,
  PACKAGE = 4,
  FLAGS = 1,
  HEADER = 2,
  RESERVE = 1,
  Len_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Len_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Len_IsValid(int value);
constexpr Len Len_MIN = LEN_USELESS;
constexpr Len Len_MAX = PACKAGE;
constexpr int Len_ARRAYSIZE = Len_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Len_descriptor();
template<typename T>
inline const std::string& Len_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Len>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Len_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Len_descriptor(), enum_t_value);
}
inline bool Len_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Len* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Len>(
    Len_descriptor(), name, value);
}
enum Max : int {
  MAX_USELESS = 0,
  LOG_COUNT = 100,
  UDP_LOG_SIZE = 64512,
  RAW_UDP_LOG_SIZE = 65507,
  TCP_LOG_SIZE = 524288,
  Max_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Max_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Max_IsValid(int value);
constexpr Max Max_MIN = MAX_USELESS;
constexpr Max Max_MAX = TCP_LOG_SIZE;
constexpr int Max_ARRAYSIZE = Max_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Max_descriptor();
template<typename T>
inline const std::string& Max_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Max>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Max_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Max_descriptor(), enum_t_value);
}
inline bool Max_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Max* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Max>(
    Max_descriptor(), name, value);
}
enum Flag : int {
  FLAG_NONE = 0,
  FLAG_COMPRESSED = 1,
  FLAG_ENCRYPTED = 2,
  FLAG_COMPRESSED_HEADER = 4,
  FLAG_ENCRYPTED_HEADER = 8,
  Flag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Flag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Flag_IsValid(int value);
constexpr Flag Flag_MIN = FLAG_NONE;
constexpr Flag Flag_MAX = FLAG_ENCRYPTED_HEADER;
constexpr int Flag_ARRAYSIZE = Flag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Flag_descriptor();
template<typename T>
inline const std::string& Flag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Flag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Flag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Flag_descriptor(), enum_t_value);
}
inline bool Flag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Flag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Flag>(
    Flag_descriptor(), name, value);
}
// ===================================================================

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
    kSeqFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 seq = 3;
  void clear_seq();
  uint64_t seq() const;
  void set_seq(uint64_t value);
  private:
  uint64_t _internal_seq() const;
  void _internal_set_seq(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tglog_v3.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t seq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class AuthReq_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthReq_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthReq_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AuthReq_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AuthReq_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AuthReq_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AuthReq_LabelsEntry_DoNotUse& other);
  static const AuthReq_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AuthReq_LabelsEntry_DoNotUse*>(&_AuthReq_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.AuthReq.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.AuthReq.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};

// -------------------------------------------------------------------

class AuthReq_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthReq_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthReq_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AuthReq_AnnotationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AuthReq_AnnotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AuthReq_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AuthReq_AnnotationsEntry_DoNotUse& other);
  static const AuthReq_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AuthReq_AnnotationsEntry_DoNotUse*>(&_AuthReq_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.AuthReq.AnnotationsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.AuthReq.AnnotationsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};

// -------------------------------------------------------------------

class AuthReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.AuthReq) */ {
 public:
  inline AuthReq() : AuthReq(nullptr) {}
  ~AuthReq() override;
  explicit PROTOBUF_CONSTEXPR AuthReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthReq(const AuthReq& from);
  AuthReq(AuthReq&& from) noexcept
    : AuthReq() {
    *this = ::std::move(from);
  }

  inline AuthReq& operator=(const AuthReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthReq& operator=(AuthReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthReq* internal_default_instance() {
    return reinterpret_cast<const AuthReq*>(
               &_AuthReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AuthReq& a, AuthReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthReq& from) {
    AuthReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.AuthReq";
  }
  protected:
  explicit AuthReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kAnnotationsFieldNumber = 2,
  };
  // map<string, string> labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 2;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // @@protoc_insertion_point(class_scope:tglog_v3.AuthReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AuthReq_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AuthReq_AnnotationsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class AuthRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.AuthRsp) */ {
 public:
  inline AuthRsp() : AuthRsp(nullptr) {}
  ~AuthRsp() override;
  explicit PROTOBUF_CONSTEXPR AuthRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRsp(const AuthRsp& from);
  AuthRsp(AuthRsp&& from) noexcept
    : AuthRsp() {
    *this = ::std::move(from);
  }

  inline AuthRsp& operator=(const AuthRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRsp& operator=(AuthRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRsp* internal_default_instance() {
    return reinterpret_cast<const AuthRsp*>(
               &_AuthRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AuthRsp& a, AuthRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRsp& from) {
    AuthRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.AuthRsp";
  }
  protected:
  explicit AuthRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:tglog_v3.AuthRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class LogReq_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogReq_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogReq_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LogReq_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogReq_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogReq_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogReq_LabelsEntry_DoNotUse& other);
  static const LogReq_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogReq_LabelsEntry_DoNotUse*>(&_LogReq_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.LogReq.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.LogReq.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};

// -------------------------------------------------------------------

class LogReq_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogReq_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogReq_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LogReq_AnnotationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LogReq_AnnotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LogReq_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogReq_AnnotationsEntry_DoNotUse& other);
  static const LogReq_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogReq_AnnotationsEntry_DoNotUse*>(&_LogReq_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.LogReq.AnnotationsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tglog_v3.LogReq.AnnotationsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};

// -------------------------------------------------------------------

class LogReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.LogReq) */ {
 public:
  inline LogReq() : LogReq(nullptr) {}
  ~LogReq() override;
  explicit PROTOBUF_CONSTEXPR LogReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogReq(const LogReq& from);
  LogReq(LogReq&& from) noexcept
    : LogReq() {
    *this = ::std::move(from);
  }

  inline LogReq& operator=(const LogReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogReq& operator=(LogReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogReq* internal_default_instance() {
    return reinterpret_cast<const LogReq*>(
               &_LogReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogReq& a, LogReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogReq& from) {
    LogReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.LogReq";
  }
  protected:
  explicit LogReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kAnnotationsFieldNumber = 2,
    kLogsFieldNumber = 3,
  };
  // map<string, string> labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 2;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // repeated .tglog_v3.Log logs = 3;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::tglog_v3::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tglog_v3::Log >*
      mutable_logs();
  private:
  const ::tglog_v3::Log& _internal_logs(int index) const;
  ::tglog_v3::Log* _internal_add_logs();
  public:
  const ::tglog_v3::Log& logs(int index) const;
  ::tglog_v3::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tglog_v3::Log >&
      logs() const;

  // @@protoc_insertion_point(class_scope:tglog_v3.LogReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogReq_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LogReq_AnnotationsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tglog_v3::Log > logs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class LogRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.LogRsp) */ {
 public:
  inline LogRsp() : LogRsp(nullptr) {}
  ~LogRsp() override;
  explicit PROTOBUF_CONSTEXPR LogRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRsp(const LogRsp& from);
  LogRsp(LogRsp&& from) noexcept
    : LogRsp() {
    *this = ::std::move(from);
  }

  inline LogRsp& operator=(const LogRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRsp& operator=(LogRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRsp* internal_default_instance() {
    return reinterpret_cast<const LogRsp*>(
               &_LogRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogRsp& a, LogRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogRsp& from) {
    LogRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.LogRsp";
  }
  protected:
  explicit LogRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqsFieldNumber = 1,
  };
  // repeated uint64 seqs = 1;
  int seqs_size() const;
  private:
  int _internal_seqs_size() const;
  public:
  void clear_seqs();
  private:
  uint64_t _internal_seqs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_seqs() const;
  void _internal_add_seqs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_seqs();
  public:
  uint64_t seqs(int index) const;
  void set_seqs(int index, uint64_t value);
  void add_seqs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      seqs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_seqs();

  // @@protoc_insertion_point(class_scope:tglog_v3.LogRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > seqs_;
    mutable std::atomic<int> _seqs_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.HeartbeatReq) */ {
 public:
  inline HeartbeatReq() : HeartbeatReq(nullptr) {}
  ~HeartbeatReq() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatReq(const HeartbeatReq& from);
  HeartbeatReq(HeartbeatReq&& from) noexcept
    : HeartbeatReq() {
    *this = ::std::move(from);
  }

  inline HeartbeatReq& operator=(const HeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatReq& operator=(HeartbeatReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatReq* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReq*>(
               &_HeartbeatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeartbeatReq& a, HeartbeatReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatReq& from) {
    HeartbeatReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.HeartbeatReq";
  }
  protected:
  explicit HeartbeatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingFieldNumber = 1,
  };
  // .google.protobuf.Timestamp ping = 1;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& ping() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_ping();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_ping();
  void set_allocated_ping(::PROTOBUF_NAMESPACE_ID::Timestamp* ping);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_ping() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* ping);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_ping();

  // @@protoc_insertion_point(class_scope:tglog_v3.HeartbeatReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ping_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.HeartbeatRsp) */ {
 public:
  inline HeartbeatRsp() : HeartbeatRsp(nullptr) {}
  ~HeartbeatRsp() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRsp(const HeartbeatRsp& from);
  HeartbeatRsp(HeartbeatRsp&& from) noexcept
    : HeartbeatRsp() {
    *this = ::std::move(from);
  }

  inline HeartbeatRsp& operator=(const HeartbeatRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRsp& operator=(HeartbeatRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRsp* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRsp*>(
               &_HeartbeatRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HeartbeatRsp& a, HeartbeatRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRsp& from) {
    HeartbeatRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.HeartbeatRsp";
  }
  protected:
  explicit HeartbeatRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPongFieldNumber = 1,
  };
  // .google.protobuf.Timestamp pong = 1;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& pong() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_pong();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pong();
  void set_allocated_pong(::PROTOBUF_NAMESPACE_ID::Timestamp* pong);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pong() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* pong);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pong();

  // @@protoc_insertion_point(class_scope:tglog_v3.HeartbeatRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pong_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class ReqHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.ReqHeader) */ {
 public:
  inline ReqHeader() : ReqHeader(nullptr) {}
  ~ReqHeader() override;
  explicit PROTOBUF_CONSTEXPR ReqHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqHeader(const ReqHeader& from);
  ReqHeader(ReqHeader&& from) noexcept
    : ReqHeader() {
    *this = ::std::move(from);
  }

  inline ReqHeader& operator=(const ReqHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqHeader& operator=(ReqHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqHeader* internal_default_instance() {
    return reinterpret_cast<const ReqHeader*>(
               &_ReqHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ReqHeader& a, ReqHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqHeader& from) {
    ReqHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.ReqHeader";
  }
  protected:
  explicit ReqHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIDFieldNumber = 1,
    kAppNameFieldNumber = 2,
    kAppVerFieldNumber = 3,
    kSdkLangFieldNumber = 4,
    kSdkVerFieldNumber = 5,
    kSdkOSFieldNumber = 6,
    kNetworkFieldNumber = 7,
    kProtoVerFieldNumber = 8,
    kHostIPFieldNumber = 9,
    kTokenFieldNumber = 11,
    kTokenTypeFieldNumber = 12,
    kSigFieldNumber = 13,
    kTsFieldNumber = 10,
  };
  // string appID = 1;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string appName = 2;
  void clear_appname();
  const std::string& appname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appname();
  PROTOBUF_NODISCARD std::string* release_appname();
  void set_allocated_appname(std::string* appname);
  private:
  const std::string& _internal_appname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appname(const std::string& value);
  std::string* _internal_mutable_appname();
  public:

  // string appVer = 3;
  void clear_appver();
  const std::string& appver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appver();
  PROTOBUF_NODISCARD std::string* release_appver();
  void set_allocated_appver(std::string* appver);
  private:
  const std::string& _internal_appver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appver(const std::string& value);
  std::string* _internal_mutable_appver();
  public:

  // string sdkLang = 4;
  void clear_sdklang();
  const std::string& sdklang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdklang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdklang();
  PROTOBUF_NODISCARD std::string* release_sdklang();
  void set_allocated_sdklang(std::string* sdklang);
  private:
  const std::string& _internal_sdklang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdklang(const std::string& value);
  std::string* _internal_mutable_sdklang();
  public:

  // string sdkVer = 5;
  void clear_sdkver();
  const std::string& sdkver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdkver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdkver();
  PROTOBUF_NODISCARD std::string* release_sdkver();
  void set_allocated_sdkver(std::string* sdkver);
  private:
  const std::string& _internal_sdkver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdkver(const std::string& value);
  std::string* _internal_mutable_sdkver();
  public:

  // string sdkOS = 6;
  void clear_sdkos();
  const std::string& sdkos() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdkos(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdkos();
  PROTOBUF_NODISCARD std::string* release_sdkos();
  void set_allocated_sdkos(std::string* sdkos);
  private:
  const std::string& _internal_sdkos() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdkos(const std::string& value);
  std::string* _internal_mutable_sdkos();
  public:

  // string network = 7;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string protoVer = 8;
  void clear_protover();
  const std::string& protover() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protover(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protover();
  PROTOBUF_NODISCARD std::string* release_protover();
  void set_allocated_protover(std::string* protover);
  private:
  const std::string& _internal_protover() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protover(const std::string& value);
  std::string* _internal_mutable_protover();
  public:

  // string hostIP = 9;
  void clear_hostip();
  const std::string& hostip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostip();
  PROTOBUF_NODISCARD std::string* release_hostip();
  void set_allocated_hostip(std::string* hostip);
  private:
  const std::string& _internal_hostip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostip(const std::string& value);
  std::string* _internal_mutable_hostip();
  public:

  // string token = 11;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string tokenType = 12;
  void clear_tokentype();
  const std::string& tokentype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokentype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokentype();
  PROTOBUF_NODISCARD std::string* release_tokentype();
  void set_allocated_tokentype(std::string* tokentype);
  private:
  const std::string& _internal_tokentype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokentype(const std::string& value);
  std::string* _internal_mutable_tokentype();
  public:

  // string sig = 13;
  void clear_sig();
  const std::string& sig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig();
  PROTOBUF_NODISCARD std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // .google.protobuf.Timestamp ts = 10;
  bool has_ts() const;
  private:
  bool _internal_has_ts() const;
  public:
  void clear_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_ts();
  void set_allocated_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_ts();
  public:
  void unsafe_arena_set_allocated_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_ts();

  // @@protoc_insertion_point(class_scope:tglog_v3.ReqHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdklang_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdkver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdkos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protover_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokentype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class Req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.Req) */ {
 public:
  inline Req() : Req(nullptr) {}
  ~Req() override;
  explicit PROTOBUF_CONSTEXPR Req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Req(const Req& from);
  Req(Req&& from) noexcept
    : Req() {
    *this = ::std::move(from);
  }

  inline Req& operator=(const Req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Req& operator=(Req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Req& default_instance() {
    return *internal_default_instance();
  }
  enum ReqCase {
    kAuthReq = 11,
    kLogReq = 12,
    kHeartbeatReq = 13,
    REQ_NOT_SET = 0,
  };

  static inline const Req* internal_default_instance() {
    return reinterpret_cast<const Req*>(
               &_Req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Req& a, Req& b) {
    a.Swap(&b);
  }
  inline void Swap(Req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Req& from) {
    Req::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.Req";
  }
  protected:
  explicit Req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIDFieldNumber = 1,
    kAppMetaDataFieldNumber = 2,
    kAuthReqFieldNumber = 11,
    kLogReqFieldNumber = 12,
    kHeartbeatReqFieldNumber = 13,
  };
  // string reqID = 1;
  void clear_reqid();
  const std::string& reqid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reqid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reqid();
  PROTOBUF_NODISCARD std::string* release_reqid();
  void set_allocated_reqid(std::string* reqid);
  private:
  const std::string& _internal_reqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqid(const std::string& value);
  std::string* _internal_mutable_reqid();
  public:

  // bytes appMetaData = 2;
  void clear_appmetadata();
  const std::string& appmetadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appmetadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appmetadata();
  PROTOBUF_NODISCARD std::string* release_appmetadata();
  void set_allocated_appmetadata(std::string* appmetadata);
  private:
  const std::string& _internal_appmetadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appmetadata(const std::string& value);
  std::string* _internal_mutable_appmetadata();
  public:

  // .tglog_v3.AuthReq authReq = 11;
  bool has_authreq() const;
  private:
  bool _internal_has_authreq() const;
  public:
  void clear_authreq();
  const ::tglog_v3::AuthReq& authreq() const;
  PROTOBUF_NODISCARD ::tglog_v3::AuthReq* release_authreq();
  ::tglog_v3::AuthReq* mutable_authreq();
  void set_allocated_authreq(::tglog_v3::AuthReq* authreq);
  private:
  const ::tglog_v3::AuthReq& _internal_authreq() const;
  ::tglog_v3::AuthReq* _internal_mutable_authreq();
  public:
  void unsafe_arena_set_allocated_authreq(
      ::tglog_v3::AuthReq* authreq);
  ::tglog_v3::AuthReq* unsafe_arena_release_authreq();

  // .tglog_v3.LogReq logReq = 12;
  bool has_logreq() const;
  private:
  bool _internal_has_logreq() const;
  public:
  void clear_logreq();
  const ::tglog_v3::LogReq& logreq() const;
  PROTOBUF_NODISCARD ::tglog_v3::LogReq* release_logreq();
  ::tglog_v3::LogReq* mutable_logreq();
  void set_allocated_logreq(::tglog_v3::LogReq* logreq);
  private:
  const ::tglog_v3::LogReq& _internal_logreq() const;
  ::tglog_v3::LogReq* _internal_mutable_logreq();
  public:
  void unsafe_arena_set_allocated_logreq(
      ::tglog_v3::LogReq* logreq);
  ::tglog_v3::LogReq* unsafe_arena_release_logreq();

  // .tglog_v3.HeartbeatReq heartbeatReq = 13;
  bool has_heartbeatreq() const;
  private:
  bool _internal_has_heartbeatreq() const;
  public:
  void clear_heartbeatreq();
  const ::tglog_v3::HeartbeatReq& heartbeatreq() const;
  PROTOBUF_NODISCARD ::tglog_v3::HeartbeatReq* release_heartbeatreq();
  ::tglog_v3::HeartbeatReq* mutable_heartbeatreq();
  void set_allocated_heartbeatreq(::tglog_v3::HeartbeatReq* heartbeatreq);
  private:
  const ::tglog_v3::HeartbeatReq& _internal_heartbeatreq() const;
  ::tglog_v3::HeartbeatReq* _internal_mutable_heartbeatreq();
  public:
  void unsafe_arena_set_allocated_heartbeatreq(
      ::tglog_v3::HeartbeatReq* heartbeatreq);
  ::tglog_v3::HeartbeatReq* unsafe_arena_release_heartbeatreq();

  void clear_req();
  ReqCase req_case() const;
  // @@protoc_insertion_point(class_scope:tglog_v3.Req)
 private:
  class _Internal;
  void set_has_authreq();
  void set_has_logreq();
  void set_has_heartbeatreq();

  inline bool has_req() const;
  inline void clear_has_req();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appmetadata_;
    union ReqUnion {
      constexpr ReqUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tglog_v3::AuthReq* authreq_;
      ::tglog_v3::LogReq* logreq_;
      ::tglog_v3::HeartbeatReq* heartbeatreq_;
    } req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class RspHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.RspHeader) */ {
 public:
  inline RspHeader() : RspHeader(nullptr) {}
  ~RspHeader() override;
  explicit PROTOBUF_CONSTEXPR RspHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RspHeader(const RspHeader& from);
  RspHeader(RspHeader&& from) noexcept
    : RspHeader() {
    *this = ::std::move(from);
  }

  inline RspHeader& operator=(const RspHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RspHeader& operator=(RspHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RspHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RspHeader* internal_default_instance() {
    return reinterpret_cast<const RspHeader*>(
               &_RspHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RspHeader& a, RspHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RspHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RspHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RspHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RspHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RspHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RspHeader& from) {
    RspHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RspHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.RspHeader";
  }
  protected:
  explicit RspHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kReqIDFieldNumber = 3,
    kAppMetaDataFieldNumber = 4,
    kCodeFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string reqID = 3;
  void clear_reqid();
  const std::string& reqid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reqid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reqid();
  PROTOBUF_NODISCARD std::string* release_reqid();
  void set_allocated_reqid(std::string* reqid);
  private:
  const std::string& _internal_reqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqid(const std::string& value);
  std::string* _internal_mutable_reqid();
  public:

  // bytes appMetaData = 4;
  void clear_appmetadata();
  const std::string& appmetadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appmetadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appmetadata();
  PROTOBUF_NODISCARD std::string* release_appmetadata();
  void set_allocated_appmetadata(std::string* appmetadata);
  private:
  const std::string& _internal_appmetadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appmetadata(const std::string& value);
  std::string* _internal_mutable_appmetadata();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tglog_v3.RspHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appmetadata_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// -------------------------------------------------------------------

class Rsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tglog_v3.Rsp) */ {
 public:
  inline Rsp() : Rsp(nullptr) {}
  ~Rsp() override;
  explicit PROTOBUF_CONSTEXPR Rsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rsp(const Rsp& from);
  Rsp(Rsp&& from) noexcept
    : Rsp() {
    *this = ::std::move(from);
  }

  inline Rsp& operator=(const Rsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rsp& operator=(Rsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rsp& default_instance() {
    return *internal_default_instance();
  }
  enum RspCase {
    kAuthRsp = 11,
    kLogRsp = 12,
    kHeartbeatRsp = 13,
    RSP_NOT_SET = 0,
  };

  static inline const Rsp* internal_default_instance() {
    return reinterpret_cast<const Rsp*>(
               &_Rsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Rsp& a, Rsp& b) {
    a.Swap(&b);
  }
  inline void Swap(Rsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rsp& from) {
    Rsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tglog_v3.Rsp";
  }
  protected:
  explicit Rsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAuthRspFieldNumber = 11,
    kLogRspFieldNumber = 12,
    kHeartbeatRspFieldNumber = 13,
  };
  // .tglog_v3.RspHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tglog_v3::RspHeader& header() const;
  PROTOBUF_NODISCARD ::tglog_v3::RspHeader* release_header();
  ::tglog_v3::RspHeader* mutable_header();
  void set_allocated_header(::tglog_v3::RspHeader* header);
  private:
  const ::tglog_v3::RspHeader& _internal_header() const;
  ::tglog_v3::RspHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tglog_v3::RspHeader* header);
  ::tglog_v3::RspHeader* unsafe_arena_release_header();

  // .tglog_v3.AuthRsp authRsp = 11;
  bool has_authrsp() const;
  private:
  bool _internal_has_authrsp() const;
  public:
  void clear_authrsp();
  const ::tglog_v3::AuthRsp& authrsp() const;
  PROTOBUF_NODISCARD ::tglog_v3::AuthRsp* release_authrsp();
  ::tglog_v3::AuthRsp* mutable_authrsp();
  void set_allocated_authrsp(::tglog_v3::AuthRsp* authrsp);
  private:
  const ::tglog_v3::AuthRsp& _internal_authrsp() const;
  ::tglog_v3::AuthRsp* _internal_mutable_authrsp();
  public:
  void unsafe_arena_set_allocated_authrsp(
      ::tglog_v3::AuthRsp* authrsp);
  ::tglog_v3::AuthRsp* unsafe_arena_release_authrsp();

  // .tglog_v3.LogRsp logRsp = 12;
  bool has_logrsp() const;
  private:
  bool _internal_has_logrsp() const;
  public:
  void clear_logrsp();
  const ::tglog_v3::LogRsp& logrsp() const;
  PROTOBUF_NODISCARD ::tglog_v3::LogRsp* release_logrsp();
  ::tglog_v3::LogRsp* mutable_logrsp();
  void set_allocated_logrsp(::tglog_v3::LogRsp* logrsp);
  private:
  const ::tglog_v3::LogRsp& _internal_logrsp() const;
  ::tglog_v3::LogRsp* _internal_mutable_logrsp();
  public:
  void unsafe_arena_set_allocated_logrsp(
      ::tglog_v3::LogRsp* logrsp);
  ::tglog_v3::LogRsp* unsafe_arena_release_logrsp();

  // .tglog_v3.HeartbeatRsp heartbeatRsp = 13;
  bool has_heartbeatrsp() const;
  private:
  bool _internal_has_heartbeatrsp() const;
  public:
  void clear_heartbeatrsp();
  const ::tglog_v3::HeartbeatRsp& heartbeatrsp() const;
  PROTOBUF_NODISCARD ::tglog_v3::HeartbeatRsp* release_heartbeatrsp();
  ::tglog_v3::HeartbeatRsp* mutable_heartbeatrsp();
  void set_allocated_heartbeatrsp(::tglog_v3::HeartbeatRsp* heartbeatrsp);
  private:
  const ::tglog_v3::HeartbeatRsp& _internal_heartbeatrsp() const;
  ::tglog_v3::HeartbeatRsp* _internal_mutable_heartbeatrsp();
  public:
  void unsafe_arena_set_allocated_heartbeatrsp(
      ::tglog_v3::HeartbeatRsp* heartbeatrsp);
  ::tglog_v3::HeartbeatRsp* unsafe_arena_release_heartbeatrsp();

  void clear_rsp();
  RspCase rsp_case() const;
  // @@protoc_insertion_point(class_scope:tglog_v3.Rsp)
 private:
  class _Internal;
  void set_has_authrsp();
  void set_has_logrsp();
  void set_has_heartbeatrsp();

  inline bool has_rsp() const;
  inline void clear_has_rsp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::tglog_v3::RspHeader* header_;
    union RspUnion {
      constexpr RspUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tglog_v3::AuthRsp* authrsp_;
      ::tglog_v3::LogRsp* logrsp_;
      ::tglog_v3::HeartbeatRsp* heartbeatrsp_;
    } rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tglog_5fv3_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Log

// string name = 1;
inline void Log::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Log::name() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Log.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.Log.name)
}
inline std::string* Log::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Log.name)
  return _s;
}
inline const std::string& Log::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Log::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_name() {
  // @@protoc_insertion_point(field_release:tglog_v3.Log.name)
  return _impl_.name_.Release();
}
inline void Log::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.Log.name)
}

// string content = 2;
inline void Log::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Log::content() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Log.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.Log.content)
}
inline std::string* Log::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Log.content)
  return _s;
}
inline const std::string& Log::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Log::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_content() {
  // @@protoc_insertion_point(field_release:tglog_v3.Log.content)
  return _impl_.content_.Release();
}
inline void Log::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.Log.content)
}

// uint64 seq = 3;
inline void Log::clear_seq() {
  _impl_.seq_ = uint64_t{0u};
}
inline uint64_t Log::_internal_seq() const {
  return _impl_.seq_;
}
inline uint64_t Log::seq() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Log.seq)
  return _internal_seq();
}
inline void Log::_internal_set_seq(uint64_t value) {
  
  _impl_.seq_ = value;
}
inline void Log::set_seq(uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:tglog_v3.Log.seq)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AuthReq

// map<string, string> labels = 1;
inline int AuthReq::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int AuthReq::labels_size() const {
  return _internal_labels_size();
}
inline void AuthReq::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AuthReq::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AuthReq::labels() const {
  // @@protoc_insertion_point(field_map:tglog_v3.AuthReq.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AuthReq::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AuthReq::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:tglog_v3.AuthReq.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 2;
inline int AuthReq::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int AuthReq::annotations_size() const {
  return _internal_annotations_size();
}
inline void AuthReq::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AuthReq::_internal_annotations() const {
  return _impl_.annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AuthReq::annotations() const {
  // @@protoc_insertion_point(field_map:tglog_v3.AuthReq.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AuthReq::_internal_mutable_annotations() {
  return _impl_.annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AuthReq::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:tglog_v3.AuthReq.annotations)
  return _internal_mutable_annotations();
}

// -------------------------------------------------------------------

// AuthRsp

// string token = 1;
inline void AuthRsp::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthRsp::token() const {
  // @@protoc_insertion_point(field_get:tglog_v3.AuthRsp.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRsp::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.AuthRsp.token)
}
inline std::string* AuthRsp::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:tglog_v3.AuthRsp.token)
  return _s;
}
inline const std::string& AuthRsp::_internal_token() const {
  return _impl_.token_.Get();
}
inline void AuthRsp::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRsp::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthRsp::release_token() {
  // @@protoc_insertion_point(field_release:tglog_v3.AuthRsp.token)
  return _impl_.token_.Release();
}
inline void AuthRsp::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.AuthRsp.token)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogReq

// map<string, string> labels = 1;
inline int LogReq::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int LogReq::labels_size() const {
  return _internal_labels_size();
}
inline void LogReq::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogReq::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogReq::labels() const {
  // @@protoc_insertion_point(field_map:tglog_v3.LogReq.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogReq::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogReq::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:tglog_v3.LogReq.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 2;
inline int LogReq::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int LogReq::annotations_size() const {
  return _internal_annotations_size();
}
inline void LogReq::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogReq::_internal_annotations() const {
  return _impl_.annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogReq::annotations() const {
  // @@protoc_insertion_point(field_map:tglog_v3.LogReq.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogReq::_internal_mutable_annotations() {
  return _impl_.annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogReq::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:tglog_v3.LogReq.annotations)
  return _internal_mutable_annotations();
}

// repeated .tglog_v3.Log logs = 3;
inline int LogReq::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int LogReq::logs_size() const {
  return _internal_logs_size();
}
inline void LogReq::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::tglog_v3::Log* LogReq::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:tglog_v3.LogReq.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tglog_v3::Log >*
LogReq::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:tglog_v3.LogReq.logs)
  return &_impl_.logs_;
}
inline const ::tglog_v3::Log& LogReq::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::tglog_v3::Log& LogReq::logs(int index) const {
  // @@protoc_insertion_point(field_get:tglog_v3.LogReq.logs)
  return _internal_logs(index);
}
inline ::tglog_v3::Log* LogReq::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::tglog_v3::Log* LogReq::add_logs() {
  ::tglog_v3::Log* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:tglog_v3.LogReq.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tglog_v3::Log >&
LogReq::logs() const {
  // @@protoc_insertion_point(field_list:tglog_v3.LogReq.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// LogRsp

// repeated uint64 seqs = 1;
inline int LogRsp::_internal_seqs_size() const {
  return _impl_.seqs_.size();
}
inline int LogRsp::seqs_size() const {
  return _internal_seqs_size();
}
inline void LogRsp::clear_seqs() {
  _impl_.seqs_.Clear();
}
inline uint64_t LogRsp::_internal_seqs(int index) const {
  return _impl_.seqs_.Get(index);
}
inline uint64_t LogRsp::seqs(int index) const {
  // @@protoc_insertion_point(field_get:tglog_v3.LogRsp.seqs)
  return _internal_seqs(index);
}
inline void LogRsp::set_seqs(int index, uint64_t value) {
  _impl_.seqs_.Set(index, value);
  // @@protoc_insertion_point(field_set:tglog_v3.LogRsp.seqs)
}
inline void LogRsp::_internal_add_seqs(uint64_t value) {
  _impl_.seqs_.Add(value);
}
inline void LogRsp::add_seqs(uint64_t value) {
  _internal_add_seqs(value);
  // @@protoc_insertion_point(field_add:tglog_v3.LogRsp.seqs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LogRsp::_internal_seqs() const {
  return _impl_.seqs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LogRsp::seqs() const {
  // @@protoc_insertion_point(field_list:tglog_v3.LogRsp.seqs)
  return _internal_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LogRsp::_internal_mutable_seqs() {
  return &_impl_.seqs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LogRsp::mutable_seqs() {
  // @@protoc_insertion_point(field_mutable_list:tglog_v3.LogRsp.seqs)
  return _internal_mutable_seqs();
}

// -------------------------------------------------------------------

// HeartbeatReq

// .google.protobuf.Timestamp ping = 1;
inline bool HeartbeatReq::_internal_has_ping() const {
  return this != internal_default_instance() && _impl_.ping_ != nullptr;
}
inline bool HeartbeatReq::has_ping() const {
  return _internal_has_ping();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HeartbeatReq::_internal_ping() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.ping_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HeartbeatReq::ping() const {
  // @@protoc_insertion_point(field_get:tglog_v3.HeartbeatReq.ping)
  return _internal_ping();
}
inline void HeartbeatReq::unsafe_arena_set_allocated_ping(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ping_);
  }
  _impl_.ping_ = ping;
  if (ping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.HeartbeatReq.ping)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatReq::release_ping() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ping_;
  _impl_.ping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatReq::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_release:tglog_v3.HeartbeatReq.ping)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ping_;
  _impl_.ping_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatReq::_internal_mutable_ping() {
  
  if (_impl_.ping_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.ping_ = p;
  }
  return _impl_.ping_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatReq::mutable_ping() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:tglog_v3.HeartbeatReq.ping)
  return _msg;
}
inline void HeartbeatReq::set_allocated_ping(::PROTOBUF_NAMESPACE_ID::Timestamp* ping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ping_);
  }
  if (ping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping));
    if (message_arena != submessage_arena) {
      ping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ping_ = ping;
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.HeartbeatReq.ping)
}

// -------------------------------------------------------------------

// HeartbeatRsp

// .google.protobuf.Timestamp pong = 1;
inline bool HeartbeatRsp::_internal_has_pong() const {
  return this != internal_default_instance() && _impl_.pong_ != nullptr;
}
inline bool HeartbeatRsp::has_pong() const {
  return _internal_has_pong();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HeartbeatRsp::_internal_pong() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.pong_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HeartbeatRsp::pong() const {
  // @@protoc_insertion_point(field_get:tglog_v3.HeartbeatRsp.pong)
  return _internal_pong();
}
inline void HeartbeatRsp::unsafe_arena_set_allocated_pong(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pong) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pong_);
  }
  _impl_.pong_ = pong;
  if (pong) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.HeartbeatRsp.pong)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatRsp::release_pong() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pong_;
  _impl_.pong_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatRsp::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_release:tglog_v3.HeartbeatRsp.pong)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pong_;
  _impl_.pong_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatRsp::_internal_mutable_pong() {
  
  if (_impl_.pong_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.pong_ = p;
  }
  return _impl_.pong_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HeartbeatRsp::mutable_pong() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:tglog_v3.HeartbeatRsp.pong)
  return _msg;
}
inline void HeartbeatRsp::set_allocated_pong(::PROTOBUF_NAMESPACE_ID::Timestamp* pong) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pong_);
  }
  if (pong) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pong));
    if (message_arena != submessage_arena) {
      pong = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pong, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pong_ = pong;
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.HeartbeatRsp.pong)
}

// -------------------------------------------------------------------

// ReqHeader

// string appID = 1;
inline void ReqHeader::clear_appid() {
  _impl_.appid_.ClearToEmpty();
}
inline const std::string& ReqHeader::appid() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_appid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.appID)
}
inline std::string* ReqHeader::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.appID)
  return _s;
}
inline const std::string& ReqHeader::_internal_appid() const {
  return _impl_.appid_.Get();
}
inline void ReqHeader::_internal_set_appid(const std::string& value) {
  
  _impl_.appid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_appid() {
  
  return _impl_.appid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_appid() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.appID)
  return _impl_.appid_.Release();
}
inline void ReqHeader::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  _impl_.appid_.SetAllocated(appid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appid_.IsDefault()) {
    _impl_.appid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.appID)
}

// string appName = 2;
inline void ReqHeader::clear_appname() {
  _impl_.appname_.ClearToEmpty();
}
inline const std::string& ReqHeader::appname() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.appName)
  return _internal_appname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_appname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.appName)
}
inline std::string* ReqHeader::mutable_appname() {
  std::string* _s = _internal_mutable_appname();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.appName)
  return _s;
}
inline const std::string& ReqHeader::_internal_appname() const {
  return _impl_.appname_.Get();
}
inline void ReqHeader::_internal_set_appname(const std::string& value) {
  
  _impl_.appname_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_appname() {
  
  return _impl_.appname_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_appname() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.appName)
  return _impl_.appname_.Release();
}
inline void ReqHeader::set_allocated_appname(std::string* appname) {
  if (appname != nullptr) {
    
  } else {
    
  }
  _impl_.appname_.SetAllocated(appname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appname_.IsDefault()) {
    _impl_.appname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.appName)
}

// string appVer = 3;
inline void ReqHeader::clear_appver() {
  _impl_.appver_.ClearToEmpty();
}
inline const std::string& ReqHeader::appver() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.appVer)
  return _internal_appver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_appver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.appVer)
}
inline std::string* ReqHeader::mutable_appver() {
  std::string* _s = _internal_mutable_appver();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.appVer)
  return _s;
}
inline const std::string& ReqHeader::_internal_appver() const {
  return _impl_.appver_.Get();
}
inline void ReqHeader::_internal_set_appver(const std::string& value) {
  
  _impl_.appver_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_appver() {
  
  return _impl_.appver_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_appver() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.appVer)
  return _impl_.appver_.Release();
}
inline void ReqHeader::set_allocated_appver(std::string* appver) {
  if (appver != nullptr) {
    
  } else {
    
  }
  _impl_.appver_.SetAllocated(appver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appver_.IsDefault()) {
    _impl_.appver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.appVer)
}

// string sdkLang = 4;
inline void ReqHeader::clear_sdklang() {
  _impl_.sdklang_.ClearToEmpty();
}
inline const std::string& ReqHeader::sdklang() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.sdkLang)
  return _internal_sdklang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_sdklang(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdklang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.sdkLang)
}
inline std::string* ReqHeader::mutable_sdklang() {
  std::string* _s = _internal_mutable_sdklang();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.sdkLang)
  return _s;
}
inline const std::string& ReqHeader::_internal_sdklang() const {
  return _impl_.sdklang_.Get();
}
inline void ReqHeader::_internal_set_sdklang(const std::string& value) {
  
  _impl_.sdklang_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_sdklang() {
  
  return _impl_.sdklang_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_sdklang() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.sdkLang)
  return _impl_.sdklang_.Release();
}
inline void ReqHeader::set_allocated_sdklang(std::string* sdklang) {
  if (sdklang != nullptr) {
    
  } else {
    
  }
  _impl_.sdklang_.SetAllocated(sdklang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdklang_.IsDefault()) {
    _impl_.sdklang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.sdkLang)
}

// string sdkVer = 5;
inline void ReqHeader::clear_sdkver() {
  _impl_.sdkver_.ClearToEmpty();
}
inline const std::string& ReqHeader::sdkver() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.sdkVer)
  return _internal_sdkver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_sdkver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdkver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.sdkVer)
}
inline std::string* ReqHeader::mutable_sdkver() {
  std::string* _s = _internal_mutable_sdkver();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.sdkVer)
  return _s;
}
inline const std::string& ReqHeader::_internal_sdkver() const {
  return _impl_.sdkver_.Get();
}
inline void ReqHeader::_internal_set_sdkver(const std::string& value) {
  
  _impl_.sdkver_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_sdkver() {
  
  return _impl_.sdkver_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_sdkver() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.sdkVer)
  return _impl_.sdkver_.Release();
}
inline void ReqHeader::set_allocated_sdkver(std::string* sdkver) {
  if (sdkver != nullptr) {
    
  } else {
    
  }
  _impl_.sdkver_.SetAllocated(sdkver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdkver_.IsDefault()) {
    _impl_.sdkver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.sdkVer)
}

// string sdkOS = 6;
inline void ReqHeader::clear_sdkos() {
  _impl_.sdkos_.ClearToEmpty();
}
inline const std::string& ReqHeader::sdkos() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.sdkOS)
  return _internal_sdkos();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_sdkos(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdkos_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.sdkOS)
}
inline std::string* ReqHeader::mutable_sdkos() {
  std::string* _s = _internal_mutable_sdkos();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.sdkOS)
  return _s;
}
inline const std::string& ReqHeader::_internal_sdkos() const {
  return _impl_.sdkos_.Get();
}
inline void ReqHeader::_internal_set_sdkos(const std::string& value) {
  
  _impl_.sdkos_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_sdkos() {
  
  return _impl_.sdkos_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_sdkos() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.sdkOS)
  return _impl_.sdkos_.Release();
}
inline void ReqHeader::set_allocated_sdkos(std::string* sdkos) {
  if (sdkos != nullptr) {
    
  } else {
    
  }
  _impl_.sdkos_.SetAllocated(sdkos, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdkos_.IsDefault()) {
    _impl_.sdkos_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.sdkOS)
}

// string network = 7;
inline void ReqHeader::clear_network() {
  _impl_.network_.ClearToEmpty();
}
inline const std::string& ReqHeader::network() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_network(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.network)
}
inline std::string* ReqHeader::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.network)
  return _s;
}
inline const std::string& ReqHeader::_internal_network() const {
  return _impl_.network_.Get();
}
inline void ReqHeader::_internal_set_network(const std::string& value) {
  
  _impl_.network_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_network() {
  
  return _impl_.network_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_network() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.network)
  return _impl_.network_.Release();
}
inline void ReqHeader::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  _impl_.network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_.IsDefault()) {
    _impl_.network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.network)
}

// string protoVer = 8;
inline void ReqHeader::clear_protover() {
  _impl_.protover_.ClearToEmpty();
}
inline const std::string& ReqHeader::protover() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.protoVer)
  return _internal_protover();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_protover(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protover_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.protoVer)
}
inline std::string* ReqHeader::mutable_protover() {
  std::string* _s = _internal_mutable_protover();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.protoVer)
  return _s;
}
inline const std::string& ReqHeader::_internal_protover() const {
  return _impl_.protover_.Get();
}
inline void ReqHeader::_internal_set_protover(const std::string& value) {
  
  _impl_.protover_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_protover() {
  
  return _impl_.protover_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_protover() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.protoVer)
  return _impl_.protover_.Release();
}
inline void ReqHeader::set_allocated_protover(std::string* protover) {
  if (protover != nullptr) {
    
  } else {
    
  }
  _impl_.protover_.SetAllocated(protover, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protover_.IsDefault()) {
    _impl_.protover_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.protoVer)
}

// string hostIP = 9;
inline void ReqHeader::clear_hostip() {
  _impl_.hostip_.ClearToEmpty();
}
inline const std::string& ReqHeader::hostip() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.hostIP)
  return _internal_hostip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_hostip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.hostIP)
}
inline std::string* ReqHeader::mutable_hostip() {
  std::string* _s = _internal_mutable_hostip();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.hostIP)
  return _s;
}
inline const std::string& ReqHeader::_internal_hostip() const {
  return _impl_.hostip_.Get();
}
inline void ReqHeader::_internal_set_hostip(const std::string& value) {
  
  _impl_.hostip_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_hostip() {
  
  return _impl_.hostip_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_hostip() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.hostIP)
  return _impl_.hostip_.Release();
}
inline void ReqHeader::set_allocated_hostip(std::string* hostip) {
  if (hostip != nullptr) {
    
  } else {
    
  }
  _impl_.hostip_.SetAllocated(hostip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostip_.IsDefault()) {
    _impl_.hostip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.hostIP)
}

// .google.protobuf.Timestamp ts = 10;
inline bool ReqHeader::_internal_has_ts() const {
  return this != internal_default_instance() && _impl_.ts_ != nullptr;
}
inline bool ReqHeader::has_ts() const {
  return _internal_has_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReqHeader::_internal_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReqHeader::ts() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.ts)
  return _internal_ts();
}
inline void ReqHeader::unsafe_arena_set_allocated_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ts_);
  }
  _impl_.ts_ = ts;
  if (ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.ReqHeader.ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReqHeader::release_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ts_;
  _impl_.ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReqHeader::unsafe_arena_release_ts() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ts_;
  _impl_.ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReqHeader::_internal_mutable_ts() {
  
  if (_impl_.ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.ts_ = p;
  }
  return _impl_.ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReqHeader::mutable_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_ts();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.ts)
  return _msg;
}
inline void ReqHeader::set_allocated_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ts_);
  }
  if (ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ts));
    if (message_arena != submessage_arena) {
      ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ts_ = ts;
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.ts)
}

// string token = 11;
inline void ReqHeader::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& ReqHeader::token() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.token)
}
inline std::string* ReqHeader::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.token)
  return _s;
}
inline const std::string& ReqHeader::_internal_token() const {
  return _impl_.token_.Get();
}
inline void ReqHeader::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_token() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.token)
  return _impl_.token_.Release();
}
inline void ReqHeader::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.token)
}

// string tokenType = 12;
inline void ReqHeader::clear_tokentype() {
  _impl_.tokentype_.ClearToEmpty();
}
inline const std::string& ReqHeader::tokentype() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.tokenType)
  return _internal_tokentype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_tokentype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tokentype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.tokenType)
}
inline std::string* ReqHeader::mutable_tokentype() {
  std::string* _s = _internal_mutable_tokentype();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.tokenType)
  return _s;
}
inline const std::string& ReqHeader::_internal_tokentype() const {
  return _impl_.tokentype_.Get();
}
inline void ReqHeader::_internal_set_tokentype(const std::string& value) {
  
  _impl_.tokentype_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_tokentype() {
  
  return _impl_.tokentype_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_tokentype() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.tokenType)
  return _impl_.tokentype_.Release();
}
inline void ReqHeader::set_allocated_tokentype(std::string* tokentype) {
  if (tokentype != nullptr) {
    
  } else {
    
  }
  _impl_.tokentype_.SetAllocated(tokentype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tokentype_.IsDefault()) {
    _impl_.tokentype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.tokenType)
}

// string sig = 13;
inline void ReqHeader::clear_sig() {
  _impl_.sig_.ClearToEmpty();
}
inline const std::string& ReqHeader::sig() const {
  // @@protoc_insertion_point(field_get:tglog_v3.ReqHeader.sig)
  return _internal_sig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqHeader::set_sig(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sig_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.ReqHeader.sig)
}
inline std::string* ReqHeader::mutable_sig() {
  std::string* _s = _internal_mutable_sig();
  // @@protoc_insertion_point(field_mutable:tglog_v3.ReqHeader.sig)
  return _s;
}
inline const std::string& ReqHeader::_internal_sig() const {
  return _impl_.sig_.Get();
}
inline void ReqHeader::_internal_set_sig(const std::string& value) {
  
  _impl_.sig_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqHeader::_internal_mutable_sig() {
  
  return _impl_.sig_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqHeader::release_sig() {
  // @@protoc_insertion_point(field_release:tglog_v3.ReqHeader.sig)
  return _impl_.sig_.Release();
}
inline void ReqHeader::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    
  } else {
    
  }
  _impl_.sig_.SetAllocated(sig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sig_.IsDefault()) {
    _impl_.sig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.ReqHeader.sig)
}

// -------------------------------------------------------------------

// Req

// string reqID = 1;
inline void Req::clear_reqid() {
  _impl_.reqid_.ClearToEmpty();
}
inline const std::string& Req::reqid() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Req.reqID)
  return _internal_reqid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Req::set_reqid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reqid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.Req.reqID)
}
inline std::string* Req::mutable_reqid() {
  std::string* _s = _internal_mutable_reqid();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Req.reqID)
  return _s;
}
inline const std::string& Req::_internal_reqid() const {
  return _impl_.reqid_.Get();
}
inline void Req::_internal_set_reqid(const std::string& value) {
  
  _impl_.reqid_.Set(value, GetArenaForAllocation());
}
inline std::string* Req::_internal_mutable_reqid() {
  
  return _impl_.reqid_.Mutable(GetArenaForAllocation());
}
inline std::string* Req::release_reqid() {
  // @@protoc_insertion_point(field_release:tglog_v3.Req.reqID)
  return _impl_.reqid_.Release();
}
inline void Req::set_allocated_reqid(std::string* reqid) {
  if (reqid != nullptr) {
    
  } else {
    
  }
  _impl_.reqid_.SetAllocated(reqid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reqid_.IsDefault()) {
    _impl_.reqid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.Req.reqID)
}

// bytes appMetaData = 2;
inline void Req::clear_appmetadata() {
  _impl_.appmetadata_.ClearToEmpty();
}
inline const std::string& Req::appmetadata() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Req.appMetaData)
  return _internal_appmetadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Req::set_appmetadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appmetadata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.Req.appMetaData)
}
inline std::string* Req::mutable_appmetadata() {
  std::string* _s = _internal_mutable_appmetadata();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Req.appMetaData)
  return _s;
}
inline const std::string& Req::_internal_appmetadata() const {
  return _impl_.appmetadata_.Get();
}
inline void Req::_internal_set_appmetadata(const std::string& value) {
  
  _impl_.appmetadata_.Set(value, GetArenaForAllocation());
}
inline std::string* Req::_internal_mutable_appmetadata() {
  
  return _impl_.appmetadata_.Mutable(GetArenaForAllocation());
}
inline std::string* Req::release_appmetadata() {
  // @@protoc_insertion_point(field_release:tglog_v3.Req.appMetaData)
  return _impl_.appmetadata_.Release();
}
inline void Req::set_allocated_appmetadata(std::string* appmetadata) {
  if (appmetadata != nullptr) {
    
  } else {
    
  }
  _impl_.appmetadata_.SetAllocated(appmetadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appmetadata_.IsDefault()) {
    _impl_.appmetadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.Req.appMetaData)
}

// .tglog_v3.AuthReq authReq = 11;
inline bool Req::_internal_has_authreq() const {
  return req_case() == kAuthReq;
}
inline bool Req::has_authreq() const {
  return _internal_has_authreq();
}
inline void Req::set_has_authreq() {
  _impl_._oneof_case_[0] = kAuthReq;
}
inline void Req::clear_authreq() {
  if (_internal_has_authreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.req_.authreq_;
    }
    clear_has_req();
  }
}
inline ::tglog_v3::AuthReq* Req::release_authreq() {
  // @@protoc_insertion_point(field_release:tglog_v3.Req.authReq)
  if (_internal_has_authreq()) {
    clear_has_req();
    ::tglog_v3::AuthReq* temp = _impl_.req_.authreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.req_.authreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::AuthReq& Req::_internal_authreq() const {
  return _internal_has_authreq()
      ? *_impl_.req_.authreq_
      : reinterpret_cast< ::tglog_v3::AuthReq&>(::tglog_v3::_AuthReq_default_instance_);
}
inline const ::tglog_v3::AuthReq& Req::authreq() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Req.authReq)
  return _internal_authreq();
}
inline ::tglog_v3::AuthReq* Req::unsafe_arena_release_authreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Req.authReq)
  if (_internal_has_authreq()) {
    clear_has_req();
    ::tglog_v3::AuthReq* temp = _impl_.req_.authreq_;
    _impl_.req_.authreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Req::unsafe_arena_set_allocated_authreq(::tglog_v3::AuthReq* authreq) {
  clear_req();
  if (authreq) {
    set_has_authreq();
    _impl_.req_.authreq_ = authreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Req.authReq)
}
inline ::tglog_v3::AuthReq* Req::_internal_mutable_authreq() {
  if (!_internal_has_authreq()) {
    clear_req();
    set_has_authreq();
    _impl_.req_.authreq_ = CreateMaybeMessage< ::tglog_v3::AuthReq >(GetArenaForAllocation());
  }
  return _impl_.req_.authreq_;
}
inline ::tglog_v3::AuthReq* Req::mutable_authreq() {
  ::tglog_v3::AuthReq* _msg = _internal_mutable_authreq();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Req.authReq)
  return _msg;
}

// .tglog_v3.LogReq logReq = 12;
inline bool Req::_internal_has_logreq() const {
  return req_case() == kLogReq;
}
inline bool Req::has_logreq() const {
  return _internal_has_logreq();
}
inline void Req::set_has_logreq() {
  _impl_._oneof_case_[0] = kLogReq;
}
inline void Req::clear_logreq() {
  if (_internal_has_logreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.req_.logreq_;
    }
    clear_has_req();
  }
}
inline ::tglog_v3::LogReq* Req::release_logreq() {
  // @@protoc_insertion_point(field_release:tglog_v3.Req.logReq)
  if (_internal_has_logreq()) {
    clear_has_req();
    ::tglog_v3::LogReq* temp = _impl_.req_.logreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.req_.logreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::LogReq& Req::_internal_logreq() const {
  return _internal_has_logreq()
      ? *_impl_.req_.logreq_
      : reinterpret_cast< ::tglog_v3::LogReq&>(::tglog_v3::_LogReq_default_instance_);
}
inline const ::tglog_v3::LogReq& Req::logreq() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Req.logReq)
  return _internal_logreq();
}
inline ::tglog_v3::LogReq* Req::unsafe_arena_release_logreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Req.logReq)
  if (_internal_has_logreq()) {
    clear_has_req();
    ::tglog_v3::LogReq* temp = _impl_.req_.logreq_;
    _impl_.req_.logreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Req::unsafe_arena_set_allocated_logreq(::tglog_v3::LogReq* logreq) {
  clear_req();
  if (logreq) {
    set_has_logreq();
    _impl_.req_.logreq_ = logreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Req.logReq)
}
inline ::tglog_v3::LogReq* Req::_internal_mutable_logreq() {
  if (!_internal_has_logreq()) {
    clear_req();
    set_has_logreq();
    _impl_.req_.logreq_ = CreateMaybeMessage< ::tglog_v3::LogReq >(GetArenaForAllocation());
  }
  return _impl_.req_.logreq_;
}
inline ::tglog_v3::LogReq* Req::mutable_logreq() {
  ::tglog_v3::LogReq* _msg = _internal_mutable_logreq();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Req.logReq)
  return _msg;
}

// .tglog_v3.HeartbeatReq heartbeatReq = 13;
inline bool Req::_internal_has_heartbeatreq() const {
  return req_case() == kHeartbeatReq;
}
inline bool Req::has_heartbeatreq() const {
  return _internal_has_heartbeatreq();
}
inline void Req::set_has_heartbeatreq() {
  _impl_._oneof_case_[0] = kHeartbeatReq;
}
inline void Req::clear_heartbeatreq() {
  if (_internal_has_heartbeatreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.req_.heartbeatreq_;
    }
    clear_has_req();
  }
}
inline ::tglog_v3::HeartbeatReq* Req::release_heartbeatreq() {
  // @@protoc_insertion_point(field_release:tglog_v3.Req.heartbeatReq)
  if (_internal_has_heartbeatreq()) {
    clear_has_req();
    ::tglog_v3::HeartbeatReq* temp = _impl_.req_.heartbeatreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.req_.heartbeatreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::HeartbeatReq& Req::_internal_heartbeatreq() const {
  return _internal_has_heartbeatreq()
      ? *_impl_.req_.heartbeatreq_
      : reinterpret_cast< ::tglog_v3::HeartbeatReq&>(::tglog_v3::_HeartbeatReq_default_instance_);
}
inline const ::tglog_v3::HeartbeatReq& Req::heartbeatreq() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Req.heartbeatReq)
  return _internal_heartbeatreq();
}
inline ::tglog_v3::HeartbeatReq* Req::unsafe_arena_release_heartbeatreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Req.heartbeatReq)
  if (_internal_has_heartbeatreq()) {
    clear_has_req();
    ::tglog_v3::HeartbeatReq* temp = _impl_.req_.heartbeatreq_;
    _impl_.req_.heartbeatreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Req::unsafe_arena_set_allocated_heartbeatreq(::tglog_v3::HeartbeatReq* heartbeatreq) {
  clear_req();
  if (heartbeatreq) {
    set_has_heartbeatreq();
    _impl_.req_.heartbeatreq_ = heartbeatreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Req.heartbeatReq)
}
inline ::tglog_v3::HeartbeatReq* Req::_internal_mutable_heartbeatreq() {
  if (!_internal_has_heartbeatreq()) {
    clear_req();
    set_has_heartbeatreq();
    _impl_.req_.heartbeatreq_ = CreateMaybeMessage< ::tglog_v3::HeartbeatReq >(GetArenaForAllocation());
  }
  return _impl_.req_.heartbeatreq_;
}
inline ::tglog_v3::HeartbeatReq* Req::mutable_heartbeatreq() {
  ::tglog_v3::HeartbeatReq* _msg = _internal_mutable_heartbeatreq();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Req.heartbeatReq)
  return _msg;
}

inline bool Req::has_req() const {
  return req_case() != REQ_NOT_SET;
}
inline void Req::clear_has_req() {
  _impl_._oneof_case_[0] = REQ_NOT_SET;
}
inline Req::ReqCase Req::req_case() const {
  return Req::ReqCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RspHeader

// int32 code = 1;
inline void RspHeader::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t RspHeader::_internal_code() const {
  return _impl_.code_;
}
inline int32_t RspHeader::code() const {
  // @@protoc_insertion_point(field_get:tglog_v3.RspHeader.code)
  return _internal_code();
}
inline void RspHeader::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void RspHeader::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tglog_v3.RspHeader.code)
}

// string msg = 2;
inline void RspHeader::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RspHeader::msg() const {
  // @@protoc_insertion_point(field_get:tglog_v3.RspHeader.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RspHeader::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.RspHeader.msg)
}
inline std::string* RspHeader::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:tglog_v3.RspHeader.msg)
  return _s;
}
inline const std::string& RspHeader::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RspHeader::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RspHeader::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RspHeader::release_msg() {
  // @@protoc_insertion_point(field_release:tglog_v3.RspHeader.msg)
  return _impl_.msg_.Release();
}
inline void RspHeader::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.RspHeader.msg)
}

// string reqID = 3;
inline void RspHeader::clear_reqid() {
  _impl_.reqid_.ClearToEmpty();
}
inline const std::string& RspHeader::reqid() const {
  // @@protoc_insertion_point(field_get:tglog_v3.RspHeader.reqID)
  return _internal_reqid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RspHeader::set_reqid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reqid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.RspHeader.reqID)
}
inline std::string* RspHeader::mutable_reqid() {
  std::string* _s = _internal_mutable_reqid();
  // @@protoc_insertion_point(field_mutable:tglog_v3.RspHeader.reqID)
  return _s;
}
inline const std::string& RspHeader::_internal_reqid() const {
  return _impl_.reqid_.Get();
}
inline void RspHeader::_internal_set_reqid(const std::string& value) {
  
  _impl_.reqid_.Set(value, GetArenaForAllocation());
}
inline std::string* RspHeader::_internal_mutable_reqid() {
  
  return _impl_.reqid_.Mutable(GetArenaForAllocation());
}
inline std::string* RspHeader::release_reqid() {
  // @@protoc_insertion_point(field_release:tglog_v3.RspHeader.reqID)
  return _impl_.reqid_.Release();
}
inline void RspHeader::set_allocated_reqid(std::string* reqid) {
  if (reqid != nullptr) {
    
  } else {
    
  }
  _impl_.reqid_.SetAllocated(reqid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reqid_.IsDefault()) {
    _impl_.reqid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.RspHeader.reqID)
}

// bytes appMetaData = 4;
inline void RspHeader::clear_appmetadata() {
  _impl_.appmetadata_.ClearToEmpty();
}
inline const std::string& RspHeader::appmetadata() const {
  // @@protoc_insertion_point(field_get:tglog_v3.RspHeader.appMetaData)
  return _internal_appmetadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RspHeader::set_appmetadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appmetadata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tglog_v3.RspHeader.appMetaData)
}
inline std::string* RspHeader::mutable_appmetadata() {
  std::string* _s = _internal_mutable_appmetadata();
  // @@protoc_insertion_point(field_mutable:tglog_v3.RspHeader.appMetaData)
  return _s;
}
inline const std::string& RspHeader::_internal_appmetadata() const {
  return _impl_.appmetadata_.Get();
}
inline void RspHeader::_internal_set_appmetadata(const std::string& value) {
  
  _impl_.appmetadata_.Set(value, GetArenaForAllocation());
}
inline std::string* RspHeader::_internal_mutable_appmetadata() {
  
  return _impl_.appmetadata_.Mutable(GetArenaForAllocation());
}
inline std::string* RspHeader::release_appmetadata() {
  // @@protoc_insertion_point(field_release:tglog_v3.RspHeader.appMetaData)
  return _impl_.appmetadata_.Release();
}
inline void RspHeader::set_allocated_appmetadata(std::string* appmetadata) {
  if (appmetadata != nullptr) {
    
  } else {
    
  }
  _impl_.appmetadata_.SetAllocated(appmetadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appmetadata_.IsDefault()) {
    _impl_.appmetadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.RspHeader.appMetaData)
}

// -------------------------------------------------------------------

// Rsp

// .tglog_v3.RspHeader header = 1;
inline bool Rsp::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Rsp::has_header() const {
  return _internal_has_header();
}
inline void Rsp::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::tglog_v3::RspHeader& Rsp::_internal_header() const {
  const ::tglog_v3::RspHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tglog_v3::RspHeader&>(
      ::tglog_v3::_RspHeader_default_instance_);
}
inline const ::tglog_v3::RspHeader& Rsp::header() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Rsp.header)
  return _internal_header();
}
inline void Rsp::unsafe_arena_set_allocated_header(
    ::tglog_v3::RspHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Rsp.header)
}
inline ::tglog_v3::RspHeader* Rsp::release_header() {
  
  ::tglog_v3::RspHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tglog_v3::RspHeader* Rsp::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tglog_v3.Rsp.header)
  
  ::tglog_v3::RspHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::tglog_v3::RspHeader* Rsp::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tglog_v3::RspHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::tglog_v3::RspHeader* Rsp::mutable_header() {
  ::tglog_v3::RspHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Rsp.header)
  return _msg;
}
inline void Rsp::set_allocated_header(::tglog_v3::RspHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tglog_v3.Rsp.header)
}

// .tglog_v3.AuthRsp authRsp = 11;
inline bool Rsp::_internal_has_authrsp() const {
  return rsp_case() == kAuthRsp;
}
inline bool Rsp::has_authrsp() const {
  return _internal_has_authrsp();
}
inline void Rsp::set_has_authrsp() {
  _impl_._oneof_case_[0] = kAuthRsp;
}
inline void Rsp::clear_authrsp() {
  if (_internal_has_authrsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rsp_.authrsp_;
    }
    clear_has_rsp();
  }
}
inline ::tglog_v3::AuthRsp* Rsp::release_authrsp() {
  // @@protoc_insertion_point(field_release:tglog_v3.Rsp.authRsp)
  if (_internal_has_authrsp()) {
    clear_has_rsp();
    ::tglog_v3::AuthRsp* temp = _impl_.rsp_.authrsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rsp_.authrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::AuthRsp& Rsp::_internal_authrsp() const {
  return _internal_has_authrsp()
      ? *_impl_.rsp_.authrsp_
      : reinterpret_cast< ::tglog_v3::AuthRsp&>(::tglog_v3::_AuthRsp_default_instance_);
}
inline const ::tglog_v3::AuthRsp& Rsp::authrsp() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Rsp.authRsp)
  return _internal_authrsp();
}
inline ::tglog_v3::AuthRsp* Rsp::unsafe_arena_release_authrsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Rsp.authRsp)
  if (_internal_has_authrsp()) {
    clear_has_rsp();
    ::tglog_v3::AuthRsp* temp = _impl_.rsp_.authrsp_;
    _impl_.rsp_.authrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rsp::unsafe_arena_set_allocated_authrsp(::tglog_v3::AuthRsp* authrsp) {
  clear_rsp();
  if (authrsp) {
    set_has_authrsp();
    _impl_.rsp_.authrsp_ = authrsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Rsp.authRsp)
}
inline ::tglog_v3::AuthRsp* Rsp::_internal_mutable_authrsp() {
  if (!_internal_has_authrsp()) {
    clear_rsp();
    set_has_authrsp();
    _impl_.rsp_.authrsp_ = CreateMaybeMessage< ::tglog_v3::AuthRsp >(GetArenaForAllocation());
  }
  return _impl_.rsp_.authrsp_;
}
inline ::tglog_v3::AuthRsp* Rsp::mutable_authrsp() {
  ::tglog_v3::AuthRsp* _msg = _internal_mutable_authrsp();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Rsp.authRsp)
  return _msg;
}

// .tglog_v3.LogRsp logRsp = 12;
inline bool Rsp::_internal_has_logrsp() const {
  return rsp_case() == kLogRsp;
}
inline bool Rsp::has_logrsp() const {
  return _internal_has_logrsp();
}
inline void Rsp::set_has_logrsp() {
  _impl_._oneof_case_[0] = kLogRsp;
}
inline void Rsp::clear_logrsp() {
  if (_internal_has_logrsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rsp_.logrsp_;
    }
    clear_has_rsp();
  }
}
inline ::tglog_v3::LogRsp* Rsp::release_logrsp() {
  // @@protoc_insertion_point(field_release:tglog_v3.Rsp.logRsp)
  if (_internal_has_logrsp()) {
    clear_has_rsp();
    ::tglog_v3::LogRsp* temp = _impl_.rsp_.logrsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rsp_.logrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::LogRsp& Rsp::_internal_logrsp() const {
  return _internal_has_logrsp()
      ? *_impl_.rsp_.logrsp_
      : reinterpret_cast< ::tglog_v3::LogRsp&>(::tglog_v3::_LogRsp_default_instance_);
}
inline const ::tglog_v3::LogRsp& Rsp::logrsp() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Rsp.logRsp)
  return _internal_logrsp();
}
inline ::tglog_v3::LogRsp* Rsp::unsafe_arena_release_logrsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Rsp.logRsp)
  if (_internal_has_logrsp()) {
    clear_has_rsp();
    ::tglog_v3::LogRsp* temp = _impl_.rsp_.logrsp_;
    _impl_.rsp_.logrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rsp::unsafe_arena_set_allocated_logrsp(::tglog_v3::LogRsp* logrsp) {
  clear_rsp();
  if (logrsp) {
    set_has_logrsp();
    _impl_.rsp_.logrsp_ = logrsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Rsp.logRsp)
}
inline ::tglog_v3::LogRsp* Rsp::_internal_mutable_logrsp() {
  if (!_internal_has_logrsp()) {
    clear_rsp();
    set_has_logrsp();
    _impl_.rsp_.logrsp_ = CreateMaybeMessage< ::tglog_v3::LogRsp >(GetArenaForAllocation());
  }
  return _impl_.rsp_.logrsp_;
}
inline ::tglog_v3::LogRsp* Rsp::mutable_logrsp() {
  ::tglog_v3::LogRsp* _msg = _internal_mutable_logrsp();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Rsp.logRsp)
  return _msg;
}

// .tglog_v3.HeartbeatRsp heartbeatRsp = 13;
inline bool Rsp::_internal_has_heartbeatrsp() const {
  return rsp_case() == kHeartbeatRsp;
}
inline bool Rsp::has_heartbeatrsp() const {
  return _internal_has_heartbeatrsp();
}
inline void Rsp::set_has_heartbeatrsp() {
  _impl_._oneof_case_[0] = kHeartbeatRsp;
}
inline void Rsp::clear_heartbeatrsp() {
  if (_internal_has_heartbeatrsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rsp_.heartbeatrsp_;
    }
    clear_has_rsp();
  }
}
inline ::tglog_v3::HeartbeatRsp* Rsp::release_heartbeatrsp() {
  // @@protoc_insertion_point(field_release:tglog_v3.Rsp.heartbeatRsp)
  if (_internal_has_heartbeatrsp()) {
    clear_has_rsp();
    ::tglog_v3::HeartbeatRsp* temp = _impl_.rsp_.heartbeatrsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rsp_.heartbeatrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tglog_v3::HeartbeatRsp& Rsp::_internal_heartbeatrsp() const {
  return _internal_has_heartbeatrsp()
      ? *_impl_.rsp_.heartbeatrsp_
      : reinterpret_cast< ::tglog_v3::HeartbeatRsp&>(::tglog_v3::_HeartbeatRsp_default_instance_);
}
inline const ::tglog_v3::HeartbeatRsp& Rsp::heartbeatrsp() const {
  // @@protoc_insertion_point(field_get:tglog_v3.Rsp.heartbeatRsp)
  return _internal_heartbeatrsp();
}
inline ::tglog_v3::HeartbeatRsp* Rsp::unsafe_arena_release_heartbeatrsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tglog_v3.Rsp.heartbeatRsp)
  if (_internal_has_heartbeatrsp()) {
    clear_has_rsp();
    ::tglog_v3::HeartbeatRsp* temp = _impl_.rsp_.heartbeatrsp_;
    _impl_.rsp_.heartbeatrsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rsp::unsafe_arena_set_allocated_heartbeatrsp(::tglog_v3::HeartbeatRsp* heartbeatrsp) {
  clear_rsp();
  if (heartbeatrsp) {
    set_has_heartbeatrsp();
    _impl_.rsp_.heartbeatrsp_ = heartbeatrsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tglog_v3.Rsp.heartbeatRsp)
}
inline ::tglog_v3::HeartbeatRsp* Rsp::_internal_mutable_heartbeatrsp() {
  if (!_internal_has_heartbeatrsp()) {
    clear_rsp();
    set_has_heartbeatrsp();
    _impl_.rsp_.heartbeatrsp_ = CreateMaybeMessage< ::tglog_v3::HeartbeatRsp >(GetArenaForAllocation());
  }
  return _impl_.rsp_.heartbeatrsp_;
}
inline ::tglog_v3::HeartbeatRsp* Rsp::mutable_heartbeatrsp() {
  ::tglog_v3::HeartbeatRsp* _msg = _internal_mutable_heartbeatrsp();
  // @@protoc_insertion_point(field_mutable:tglog_v3.Rsp.heartbeatRsp)
  return _msg;
}

inline bool Rsp::has_rsp() const {
  return rsp_case() != RSP_NOT_SET;
}
inline void Rsp::clear_has_rsp() {
  _impl_._oneof_case_[0] = RSP_NOT_SET;
}
inline Rsp::RspCase Rsp::rsp_case() const {
  return Rsp::RspCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tglog_v3

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tglog_v3::ProtoVer> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tglog_v3::ProtoVer>() {
  return ::tglog_v3::ProtoVer_descriptor();
}
template <> struct is_proto_enum< ::tglog_v3::Magic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tglog_v3::Magic>() {
  return ::tglog_v3::Magic_descriptor();
}
template <> struct is_proto_enum< ::tglog_v3::Len> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tglog_v3::Len>() {
  return ::tglog_v3::Len_descriptor();
}
template <> struct is_proto_enum< ::tglog_v3::Max> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tglog_v3::Max>() {
  return ::tglog_v3::Max_descriptor();
}
template <> struct is_proto_enum< ::tglog_v3::Flag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tglog_v3::Flag>() {
  return ::tglog_v3::Flag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tglog_5fv3_2eproto
